<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Dallin Clark — Graphics Programmer</title>
  <link href="https://fonts.googleapis.com/css2?family=Roboto&family=Lato&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="project_styles.css">
</head>

<body>  
  <div class="main-container">
    <header>
      <div class="header-container">
        <h1>Dallin Clark — Graphics Programmer</h1>
        <nav>
          <a href="../index.html">Home</a>
          <a href="../media/Dallin_Clark_Resume_2025.pdf" target="_blank">Resume</a>
          <a href="https://github.com/DallinClark" target="_blank">
            <img src="https://cdn.jsdelivr.net/npm/simple-icons@v9/icons/github.svg" alt="GitHub" class="icon" />
          </a>
          <a href="https://linkedin.com/in/dallin-clark1" target="_blank">
            <img src="https://cdn.jsdelivr.net/npm/simple-icons@v9/icons/linkedin.svg" alt="LinkedIn" class="icon" />
          </a>
        </nav>
      </div>
    </header>
        <div class="raytracer-banner">
      <h1>Honey Buisness Pipeline</h1>
    </div>

  <section id="description" class="project-detail-section">
  <!-- Project details -->
  <div class="project-details">
    <p>
      <a href="https://github.com/dallinclark/bobo-pipeline">This project</a> is a <b>USD</b>-based pipeline I developed for the short film <i>Honey Business</i> by the BYU Center for Animation.  
      It builds on <a href="https://github.com/scottdmilner/dungeon-pipeline">dungeon pipeline</a> by 
      <a href="https://www.linkedin.com/in/sdmilner/" target="_blank" rel="noopener noreferrer">Scott Milner</a>
       used in the short film <i>Love and Gold</i>.
      <br>  <br>
      It consists of a full production framework that streamlines asset publishing, shot setup, look development, layout creation, render submission, and more.  
      It's purpose is to standardize workflows across <b>Maya</b>, <b>Houdini</b>, <b>Substance Painter</b>, and <b>Nuke</b>, and it utilizes <b>Python</b> and USD.
      <br><br>
      Read more about some of my contributions below!
    </p>
  </div>

  <!-- Features -->
  <div class="project-features">
    <h2>Maya/Houdini USD Layout Creation</h2>
    <hr class="section-divider">
       <p>
          This toolset provides a solution for authoring USD layout layers directly within Maya or Houdini, which can then be used downstream for animation, rendering, etc. 
          <br><br>
          Using <b>Maya’s USD Proxy Shape node</b>, it automates stage creation in Maya by generating a structured USD hierarchy that is consistent thourghout the pipe.
          I also updated an existing <b>Houdini HDA</b>, that sets up the same USD structure, allowing for layout creation or tweaking in either software.

        <p>
          The tool includes a set of custom <b>Qt</b> interfaces that query <b>ShotGrid</b> for the list of environments to build upon, and a list of assets to reference in. 
          Artists can assign or replace layout contents using dropdowns and selection UIs, ensuring consistency with production-tracked assets. 
          These selections drive the creation of reference prims, grouped by logical layout groupings, and organized under a user-defined hierarchy inside the USD stage.
        </p>

        <div class="image-row">
          <img src="../media/projects/env_qt.png" alt="Qt Layout Tool UI" class="tool-image">
          <img src="../media/projects/reference_qt.png" alt="Qt Layout Tool UI" class="tool-image">
        </div>

        <p>
          I also developed tools in Maya and Houdini that allow for instant recreation of layouts published in the other software. 
          <br><br>
          This allows layouts to be built and changed in Maya or Houdini regardless of the DCC used in previous work on this set.
          This works regardless of the step in produciton, or even whether or not assets are finished becuase of <b>USD references</b>. 
          This lets anyone in the production pipline make layout edits that are instantly updated everywhere else.

        </p>


          <div class="layout-tools-row">
            <figure class="layout-tool">
              <img src="../media/projects/maya_layout.png" alt="Maya Layout Tool UI" class="layout-tool-image">
              <figcaption>Maya Layout</figcaption>
            </figure>
          
            <figure class="layout-tool">
              <img src="../media/projects/houdini_layout.png" alt="Houdini Layout Tool UI" class="layout-tool-image">
              <figcaption>Houdini Layout From Maya</figcaption>
            </figure>
          
            <figure class="layout-tool">
              <img src="../media/projects/final_shot.png" alt="Final Shot" class="layout-tool-image">
              <figcaption>Final Shot</figcaption>
            </figure>
          </div>
          
          <p class="layout-artist">
            Layout Artist: <a href="https://www.linkedin.com/in/isabella-francis-4996ba320/" target="_blank" rel="noopener noreferrer">Isabella Francis</a>
          </p>
        

        <p>
          Altogether, this tool bridges the gap between DCCs, allowing layout to begin in Maya where artists are most comfortable,
          while ensuring compatibility and fidelity with downstream USD workflows in Solaris or any Hydra-compliant renderer.
        </p>

    <h2>Look Dev Pipeline</h2>
    <hr class="section-divider">
        <p>
          This custom tool streamlines the surfacing workflow across Substance Painter, ShotGrid, 
          and Houdini by allowing artists to export textures for multiple models simultaneously. 
          Inside Substance Painter, users can associate each texture set with a specific production asset, 
          enabling efficient lookdev for entire sets or character kits in a single session. 
          This allows multiple props or character parts to be painted together but still exported to their own correct destinations.
        </p>

        <img src="media/sp_texture_mapping_ui.png" alt="Substance Painter Export Mapping UI" class="tool-image">

        <p>
          Upon export, the tool prompts the user to specify metadata for each asset, including 
          render pass type (e.g., hero, midground), material variant (e.g., dusty, wet), 
          and geometry variant (e.g., damaged, clean). It then automatically generates the correct 
          folder structure, converts texture maps to <code>.tex</code> files optimized for RenderMan, 
          and updates the ShotGrid database with any new variants. This ensures surfacing work is both technically correct and pipeline-aware, 
          reducing the risk of asset mismatches in downstream departments.
        </p>

        <img src="media/variant_entry_dialog.png" alt="Variant Entry Dialog" class="tool-image">

        <p>
          Once textures are in place, a Houdini-side tool reads the variant data and automatically builds RenderMan layered 
          materials. Based on the assigned material and geometry variants, it creates networks that blend maps correctly, 
          load the appropriate <code>.tex</code> files, and apply the correct shading models per object type. Artists don’t 
          need to manually set up material networks—just select the asset, and the tool builds everything procedurally.
        </p>

        <img src="media/renderman_material_setup.png" alt="Auto-Built Layered Material in Houdini" class="tool-image">

        <p>
          This tool significantly accelerates lookdev for asset libraries and hero props by allowing for batched 
          surfacing workflows while preserving full control over variant naming, ShotGrid integration, and downstream 
          material generation. It also ensures that shading setups in Houdini match exactly what was exported from Substance, 
          with no manual relinking or asset guessing.
        </p>
        <h2>Shotgrid API Bi-Directional Integration</h2>
        <hr class="section-divider">


            <p>
              I built upon the internal ShotGrid API used in our pipeline to support full bi-directional communication. Previously, the API was limited to read-only access—artists could only query data like tasks, users, or version history. 
              I extended this functionality to allow write-access as well, enabling DCC tools to publish new data directly to ShotGrid without leaving the application.
            </p>

            <img src="media/shotgrid_publish_ui.png" alt="DCC Publish UI" class="tool-image">

            <p>
              I designed a set of lightweight, extensible data structures to represent ShotGrid entities including <code>User</code>, 
              <code>Task</code>, and <code>Version</code> These structs are now used throughout the pipeline tools to query 
              existing production data and to construct and submit new entities when artists publish. 
              All entity creation logic follows studio schema and validation rules, so new records integrate seamlessly with scheduling and review systems.
            </p>

            <p>
              With this update, publishing tasks and versions can now be triggered directly from Maya, Houdini, or 
              Nuke using custom UI tools that wrap this new API. Artists can publish lookdev variants, shot versions, 
              or rigging WIPs without needing to manually enter data in the ShotGrid web interface. This reduces context 
              switching, increases data accuracy, and allows publishing tools to intelligently infer metadata based on the artist’s current scene or file.
            </p>

            <p>
              This upgrade unlocked an entire layer of automation in our DCC tools, from asset publishing and task 
              tracking to auto-linking dependencies across departments. The new API structure is also modular and ready 
              to support future features like automated thumbnail generation, cross-app asset history, and pipeline event hooks.
            </p>



</section>
</body>
</html>
